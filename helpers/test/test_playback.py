import datetime
import logging
from typing import Any

import pandas as pd

import helpers.playback as plbck
import helpers.unit_test as hut

_LOG = logging.getLogger(__name__)


class TestJsonRoundtrip1(hut.TestCase):
    """
    Test roundtrip conversion through jsonpickle for different types.
    """

    def test1(self) -> None:
        obj = 3
        #
        plbck.round_trip_convert(obj, logging.DEBUG)

    def test2(self) -> None:
        obj = "hello"
        #
        plbck.round_trip_convert(obj, logging.DEBUG)

    def test3(self) -> None:
        data = {
            "Product": ["Desktop Computer", "Tablet", "iPhone", "Laptop"],
            "Price": [700, 250, 800, 1200],
        }
        df = pd.DataFrame(data, columns=["Product", "Price"])
        df.index.name = "hello"
        #
        obj = df
        plbck.round_trip_convert(obj, logging.DEBUG)

    def test4(self) -> None:
        obj = datetime.date(2015, 1, 1)
        #
        plbck.round_trip_convert(obj, logging.DEBUG)


class TestPlaybackInputOutput1(hut.TestCase):
    """
    Freeze the output of Playback.
    """

    def _helper(self, mode: str, *args: Any, **kwargs: Any) -> None:
        # Define a function to generate a unit test for.
        def get_result(a: Any, b: Any) -> Any:
            if isinstance(a, datetime.date) and isinstance(b, datetime.date):
                return abs(a - b)
            if isinstance(a, dict) and isinstance(b, dict):
                c = {}
                c.update(a)
                c.update(b)
                return c
            return a + b

        # Generate a unit test for `get_result` with Playback.
        playback = plbck.Playback(mode, "get_result", *args, **kwargs)
        res = get_result(*args, **kwargs)
        code = playback.run(res)
        # Freeze the Playback output (unit test code).
        self.check_string(code)
        # Execute the unit test code generated by Playback.
        _LOG.debug("Testing code:\n%s", code)
        exec(code, locals())

    def test1(self) -> None:
        """
        Test for int inputs.
        """
        # Create inputs.
        a = 3
        b = 2
        # Generate, freeze and execute a unit test.
        self._helper("assert_equal", a=a, b=b)

    def test2(self) -> None:
        """
        Test for string inputs.
        """
        # Create inputs.
        a = "test"
        b = "case"
        # Generate, freeze and execute a unit test.
        self._helper("assert_equal", a=a, b=b)

    def test3(self) -> None:
        """
        Test for list inputs.
        """
        # Create inputs.
        a = [1, 2, 3]
        b = [4, 5, 6]
        # Generate, freeze and execute a unit test.
        self._helper("assert_equal", a=a, b=b)

    def test4(self) -> None:
        """
        Test for dict inputs.
        """
        # Create inputs.
        a = {"1": 2}
        b = {"3": 4}
        # Generate, freeze and execute a unit test.
        self._helper("assert_equal", a=a, b=b)

    def test5(self) -> None:
        """
        Test for pd.DataFrame inputs.
        """
        # Create inputs.
        a = pd.DataFrame({"Price": [700, 250, 800, 1200]})
        b = pd.DataFrame({"Price": [1, 1, 1, 1]})
        # Generate, freeze and execute a unit test.
        self._helper("assert_equal", a=a, b=b)

    def test6(self) -> None:
        """
        Test for datetime.date inputs (using `jsonpickle`).
        """
        # Create inputs.
        a = datetime.date(2015, 1, 1)
        b = datetime.date(2012, 1, 1)
        # Generate, freeze and execute a unit test.
        self._helper("assert_equal", a=a, b=b)

    def test7(self) -> None:
        """
        Test for int inputs with check_string.
        """
        # Create inputs.
        a = 3
        b = 2
        # Generate, freeze and execute a unit test.
        self._helper("check_string", a=a, b=b)

    def test8(self) -> None:
        """
        Test for string inputs with check_string.
        """
        # Create inputs.
        a = "test"
        b = "case"
        # Generate, freeze and execute a unit test.
        self._helper("check_string", a=a, b=b)

    def test9(self) -> None:
        """
        Test for list inputs with check_string.
        """
        # Create inputs.
        a = [1, 2, 3]
        b = [4, 5, 6]
        # Generate, freeze and execute a unit test.
        self._helper("check_string", a=a, b=b)

    def test10(self) -> None:
        """
        Test for dict inputs with check_string.
        """
        # Create inputs.
        a = {"1": 2}
        b = {"3": 4}
        # Generate, freeze and execute a unit test.
        self._helper("check_string", a=a, b=b)

    def test11(self) -> None:
        """
        Test for pd.DataFrame inputs with check_string.
        """
        # Create inputs.
        a = pd.DataFrame({"Price": [700, 250, 800, 1200]})
        b = pd.DataFrame({"Price": [1, 1, 1, 1]})
        # Generate, freeze and execute a unit test.
        self._helper("check_string", a=a, b=b)


class TestPlaybackUseCase1(hut.TestCase):
    def test1(self) -> None:
        def get_result(a: Any, b: Any) -> Any:
            c = a + b
            if use_playback:
                playback = plbck.Playback("assert_equal", "get_result", a=a, b=b)
                # The output is the code of a unit test that checks that `c` is
                # equal to the result of running `get_result(a, b)` without Playback.
                output = playback.run(c)
                # Return the code.
                res = output
            else:
                # Return the result of running `get_result(a, b)` without Playback.
                res = c
            return res

        # Execute without Playback.
        a = 3
        b = 2
        use_playback = False
        ret = get_result(a=a, b=b)
        self.assertEqual(ret, 5)
        # Execute with Playback (generating a unit test for `get_result`).
        a = 3
        b = 2
        use_playback = True
        code = get_result(a=a, b=b)
        self.check_string(code)
        # Execute the unit test generated by Playback (make sure it passes).
        _LOG.debug("Testing code:\n%s", code)
        # We need to disable the unit test generation inside the function `get_result`.
        use_playback = False
        exec(code, locals())

    def test2(self) -> None:
        def get_result(a: Any, b: Any) -> Any:
            c = a + b
            if use_playback:
                playback = plbck.Playback("check_string", "get_result", a=a, b=b)
                # The output is the code of a unit test that checks that `c` is
                # equal to the result of running `get_result(a, b)` without Playback.
                output = playback.run(c)
                # Return the code.
                res = output
            else:
                # Return the result of running `get_result(a, b)` without Playback.
                res = c
            return res

        # Execute without Playback.
        a = pd.DataFrame({"Price": [700, 250, 800, 1200]})
        b = pd.DataFrame({"Price": [1, 1, 1, 1]})
        use_playback = False
        ret = get_result(a=a, b=b)
        assert ret.equals(pd.DataFrame({"Price": [701, 251, 801, 1201]}))
        # Execute with Playback (generating a unit test for `get_result`).
        a = pd.DataFrame({"Price": [700, 250, 800, 1200]})
        b = pd.DataFrame({"Price": [1, 1, 1, 1]})
        use_playback = True
        code = get_result(a=a, b=b)
        self.check_string(code)
        # Execute the unit test generated by Playback (make sure it passes).
        _LOG.debug("Testing code:\n%s", code)
        # We need to disable the unit test generation inside the function `get_result`.
        use_playback = False
        exec(code, locals())
